#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S3,     IRseeker,       sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     motorR,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorL,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servoFlip,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "rdpartyrobotcdr-3.3.1\drivers\hitechnic-irseeker-v2.h"

// Pause for the other alliance?
#define BEFORE_START_10MS 0
#define DRIVE_SPEED 60
#define ENCODER_TICKS_INCH 100
#define ENCODER_TICKS_90_TURN 2275

string Left = "L";
string Right = "R";

int DistanceToIR = 0; //Distance from beacon
int _dirAC = 0; //Sensor number
int acS1, acS2, acS3, acS4, acS5 = 0; //Stores IR sensor values
int maxSig = 0; // The max signal strength from the seeker.
int flipper_start_pos = 0; //Flat
int turnTime = 87; // Time (ms) to complete 90 degree turn.
// This variable is set by the MoveToIR function (It knows where the beacon is located).
string beaconDirection = "L"; // Which side of the robot is the beacon on
int irGoal = 3; // Which sensor is pointing to the left or right of the robot?
int servoMoveRange = 190; // Servo location to dump block (assumes 0 = rest position).

float InchesToTape = 32;
float InchesToRamp = 45;

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  definitiona and variables for the motor slew rate controller.              */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

#define MOTOR_NUM               5
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 5       // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        15      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10

// Array to hold requested speed for the motors
int motorReq[ MOTOR_NUM ];

// Array to hold "slew rate" for the motors, the maximum change every time the task
// runs checking current mootor speed.
int motorSlew[ MOTOR_NUM ];

// Function declarations.
void Turn90(string direction);
void ResetEncoders();
void StopMotors();
void PointTurn(string direction);

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  Task  - compares the requested speed of each motor to the current speed    */
/*          and increments or decrements to reduce the difference as necessary */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

task MotorSlewRateTask()
{
	int motorIndex;
	int motorTmp;

	// Initialize stuff
	for(motorIndex=0;motorIndex<MOTOR_NUM;motorIndex++)
	{
		motorReq[motorIndex] = 0;
		motorSlew[motorIndex] = MOTOR_DEFAULT_SLEW_RATE;
	}

	// run task until stopped
	while( true )
	{
		// run loop for every motor
		for( motorIndex=0; motorIndex<MOTOR_NUM; motorIndex++)
		{
			// So we don't keep accessing the internal storage
			motorTmp = motor[ motorIndex ];

			// Do we need to change the motor value ?
			if( motorTmp != motorReq[motorIndex] )
			{
				// increasing motor value
				if( motorReq[motorIndex] > motorTmp )
				{
					motorTmp += motorSlew[motorIndex];
					// limit
					if( motorTmp > motorReq[motorIndex] )
						motorTmp = motorReq[motorIndex];
				}

				// decreasing motor value
				if( motorReq[motorIndex] < motorTmp )
				{
					motorTmp -= motorSlew[motorIndex];
					// limit
					if( motorTmp < motorReq[motorIndex] )
						motorTmp = motorReq[motorIndex];
				}

				// finally set motor
				motor[motorIndex] = motorTmp;
			}
		}

		// Wait approx the speed of motor update over the spi bus
		wait1Msec( MOTOR_TASK_DELAY );
	}
}

void initializeRobot()
{
	servoChangeRate[servoFlip] = 25; // Servo Change Rate, positions per update (20ms).
	servo[servoFlip] = flipper_start_pos;
	ResetEncoders();
	//disableDiagnosticsDisplay();
}

int convert(float inches)
{
	return (int)(inches * ENCODER_TICKS_INCH);
}

void driveMotors(int lspeed, int rspeed)
{
	motorReq[motorL] = lspeed;
	motorReq[motorR] = rspeed;
}

void MoveForward ()
{
	driveMotors (DRIVE_SPEED, DRIVE_SPEED);
}

void StopMotors()
{
	driveMotors(0,0);
	wait10Msec(20);
}

void ResetEncoders()
{
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;
	wait10Msec(30);
}

void GoInches(float inches, int speed)
{
	ResetEncoders();
	wait1Msec(200);
	motorReq[motorL] = speed;
	motorReq[motorR] = speed;
	//motor[motorL] = speed;
	//motor[motorR] = speed;
	while ((abs(nMotorEncoder[motorR]) + abs(nMotorEncoder[motorL])) / 2 < (convert(inches)))
	{
	}

	StopMotors();
}

// Run servo to dump block and return arm to rest.
void DumpBlock()
{
	servo[servoFlip] = servoMoveRange; //Flip the block out.
	while (ServoValue[servoFlip] < servoMoveRange)
	{
		wait1Msec(20);
	}
	wait1Msec(500);
	servo[servoFlip] = ServoValue[servoFlip] - servoMoveRange; //Move back to the starting position.
}

// Move back to start after a trip to the IR beacon.
void BackToStart()
{
	if (DistanceToIR == 0)
	{
		return;
	}

	StopTask(MotorSlewRateTask);
	//nxtDisplayTextLine(4, "Distance: %d", DistanceToIR);
	ResetEncoders();
	nMotorEncoderTarget[motorL] = DistanceToIR;
	nMotorEncoderTarget[motorR] = DistanceToIR;
	wait10Msec(30);
	motor[motorL] = -DRIVE_SPEED;
	motor[motorR] = -DRIVE_SPEED;
	while (nMotorRunState[motorL] != runStateIdle || nMotorRunState[motorR] != runStateIdle)
	{
		nxtDisplayTextLine(3, "Enc: %d", nMotorEncoder[motorL]);
		nxtDisplayTextLine(4, "RunState: %d", nMotorRunState[motorL]);
	}

	StartTask(MotorSlewRateTask);
	wait10Msec(2);
}

void MovetoIR()
{
	int FindState = 1;
	bool FoundIt = false;
	nMotorEncoder[motorL] = 0;
	nMotorEncoder[motorR] = 0;
	wait1Msec(200);

	// Use a timer to prevent runaway!
	ClearTimer(T1);
	// Start moving.
	driveMotors(DRIVE_SPEED, DRIVE_SPEED);
	// Adjust timer if needed, just enough to get to the IR.
	// If we don't find it, timeout and move on.
	while(!FoundIt && time1[T1] < 5000)
	{
		switch (FindState)
		{
		case 1:
			// Look for target
			// Get the direction.
			_dirAC = HTIRS2readACDir(IRseeker);
			// Make 0 straight ahead, all positive, no left or right worry.
			_dirAC = _dirAC - 5;
			// Set the direction for the turn90 function.
		beaconDirection = _dirAC < 0 ? "L" : "R";
			// We need it without sign so left and right are ignored.
			_dirAC = abs(_dirAC);
			nxtDisplayTextLine(1, "Direction: %d", _dirAC);
			// Get the strength.
			HTIRS2readAllACStrength(IRseeker, acS1, acS2, acS3, acS4, acS5);
		maxSig = (acS1 > acS2) ? acS1 : acS2;
		maxSig = (maxSig > acS3) ? maxSig : acS3;
		maxSig = (maxSig > acS4) ? maxSig : acS4;
		maxSig = (maxSig > acS5) ? maxSig : acS5;
			nxtDisplayTextLine(2, "maxSig: %d", maxSig);

			wait10Msec(2);
			if (_dirAC >= irGoal && _dirAC != 5)
			{
				StopMotors();
				DistanceToIR = nMotorEncoder[motorL];
				FindState++;
			}
			break;
		case 2:
			// Look for strongest signal.
			FindState++;
			break;
		case 3:
			// Backup a little.
			FindState++;
			FoundIt = true;
			break;
		}
	}
}

// Test functions here.
// Run servo DumpBlocto dump block and return arm to rest.
void MoveServo()
{
	servo[servoFlip] = servoMoveRange; //Flip the block out.
	while (ServoValue[servoFlip] < servoMoveRange)
	{
		wait1Msec(20);
	}

	servo[servoFlip] = ServoValue[servoFlip] - servoMoveRange; //Move back to the starting position.
}

void LookForBeacon()
{
	while (true)
	{
		_dirAC = HTIRS2readACDir(IRseeker);
		// Make 0 straight ahead, all positive, no left or right worry.
		_dirAC = _dirAC - 5;
		// Set the direction for the turn90 function.
	beaconDirection = _dirAC < 0 ? "L" : "R";
		// We need it without sign so left and right are ignored.
		_dirAC = abs(_dirAC);
		nxtDisplayTextLine(1, "Direction: %d", _dirAC);
		// Get the strength.
		HTIRS2readAllACStrength(IRseeker, acS1, acS2, acS3, acS4, acS5);
	maxSig = (acS1 > acS2) ? acS1 : acS2;
	maxSig = (maxSig > acS3) ? maxSig : acS3;
	maxSig = (maxSig > acS4) ? maxSig : acS4;
	maxSig = (maxSig > acS5) ? maxSig : acS5;
		nxtDisplayTextLine(2, "maxSig: %d", maxSig);

		wait10Msec(2);
	}
}

void DriveSquareTest()
{
	Turn90(Left);
	GoInches(InchesToTape, DRIVE_SPEED);
	Turn90(Left);
	GoInches(InchesToTape, DRIVE_SPEED);
	Turn90(Left);
	GoInches(InchesToTape, DRIVE_SPEED);
	Turn90(Left);
	GoInches(InchesToTape, DRIVE_SPEED);

	Turn90(Right);
	GoInches(InchesToTape, DRIVE_SPEED);
	Turn90(Right);
	GoInches(InchesToTape, DRIVE_SPEED);
	Turn90(Right);
	GoInches(InchesToTape, DRIVE_SPEED);
	Turn90(Right);
	GoInches(InchesToTape, DRIVE_SPEED);
}

void DriveSquarePoint(string direction)
{
	if (direction == Left){
		PointTurn(Left);
		GoInches(InchesToTape, DRIVE_SPEED);
		PointTurn(Left);
		GoInches(InchesToTape, DRIVE_SPEED);
		PointTurn(Left);
		GoInches(InchesToTape, DRIVE_SPEED);
		PointTurn(Left);
		GoInches(InchesToTape, DRIVE_SPEED);
	}

	else{
		PointTurn(Right);
		GoInches(InchesToTape, DRIVE_SPEED);
		PointTurn(Right);
		GoInches(InchesToTape, DRIVE_SPEED);
		PointTurn(Right);
		GoInches(InchesToTape, DRIVE_SPEED);
		PointTurn(Right);
		GoInches(InchesToTape, DRIVE_SPEED);
	}
}

// This function uses encoders to turn.
void PointTurn(string direction)
{
	// Adjust the requested direction to reflect the actual location of the beacon.
	direction = beaconDirection == direction ? "L" : "R";
	StopTask(MotorSlewRateTask);
	ResetEncoders();
	nMotorEncoderTarget[motorL] = ENCODER_TICKS_90_TURN;
	nMotorEncoderTarget[motorR] = ENCODER_TICKS_90_TURN;
	wait1Msec(200);
	motor[motorL] = direction == "L" ? -DRIVE_SPEED : DRIVE_SPEED;
	motor[motorR] = direction == "L" ? DRIVE_SPEED : -DRIVE_SPEED;
	while (nMotorRunState[motorL] != runStateIdle || nMotorRunState[motorR] != runStateIdle)
	{
	}
	StartTask(MotorSlewRateTask);
}

// Turn 90 degrees.
void Turn90(string direction)
{
	// Adjust the requested direction to reflect the actual location of the beacon.
direction = beaconDirection == direction ? "L" : "R";
motorReq[motorL] = direction == "L" ? -DRIVE_SPEED : DRIVE_SPEED;
motorReq[motorR] = direction == "L" ? DRIVE_SPEED : -DRIVE_SPEED;
	wait10Msec(turnTime);
	StopMotors();
}

task main()
{
	StartTask(MotorSlewRateTask);
	wait10Msec(100);
	//Test Function Here
	//MoveServo();
	//Turn90(Right);
	//PointTurn(Left);
	//DriveSquareTest();
	DriveSquarePoint(Right);
	//LookForBeacon();
	//driveMotors(20, 20);
	StopMotors();
	StopTask(MotorSlewRateTask);
	//motor[motorL] = 0;
	//motor[motorR] = 0;
	while(true)
	{
	}
	// Wait for FCS to stop us
	//EndOfMatch();
}
